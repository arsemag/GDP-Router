#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
import copy


class Router:
    relations = {}
    sockets = {}
    ports = {}
    forwarding_table = []    #MY ROUTE

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation




            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))



    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))

                data = json.loads(msg)



                self.process_message(data, srcif)



    def process_message(self, message, source):
        msg_type = message["type"]
        if msg_type == "update":
            self.update_forwarding_table(message, source)
        if msg_type == "data":
            self.handle_data_message(message, source)
        if msg_type == "dump":
            self.handle_dump(message, source)
        if msg_type == "withdraw":
            self.handle_withdrawel(message, source)

    def handle_dump(self, message, source):
        aggregated = self.now_aggregate(self.forwarding_table)

        table_message = {
                "src": self.our_addr(message["src"]),
                "dst": source,
                "type": "table",
                "msg": aggregated,
            }

        self.send(message["src"], json.dumps(table_message))

    def now_aggregate(self, routes):
        aggregated_routes = routes[:]  # Copy the list of routes to aggregate
        has_changed = True  # Flag to check if any aggregation has occurred

        def route_sort_key(route):
            # Key function to sort routes based on several factors
            return (
                route["peer"],  # Peer router for comparison
                int(route["localpref"]),  # Local preference (converted to integer)
                route["selfOrigin"],  # Self-origin flag
                route["ASPath"],  # Autonomous System path
                route["origin"],  # Origin type
                self.ip_to_int(route["network"]),  # Convert network IP to integer for easier sorting
                self.netmask_to_prefix(route["netmask"])  # Convert netmask to prefix length
            )

        while has_changed:  # Loop until no changes are detected in the aggregation
            aggregated_routes.sort(key=route_sort_key)  # Sort the routes
            has_changed = False  # Reset the flag for aggregation change
            new_aggregated_list = []  # List to store new aggregated routes
            has_been_aggregated = [False] * len(aggregated_routes)  # Track routes that have been aggregated
            i = 0  # Initialize index for the main loop

            while i < len(aggregated_routes):  # Iterate over all routes
                if has_been_aggregated[i]:  # Skip already aggregated routes
                    i += 1
                    continue
                origin = aggregated_routes[i]  # Current route being considered for aggregation
                merged = False  # Flag to check if this route will be merged with another
                j = i + 1  # Initialize index for the second route to compare with

                while j < len(aggregated_routes):  # Compare with subsequent routes
                    if not has_been_aggregated[j]:  # Skip already aggregated routes
                        last = aggregated_routes[j]  # The next route to compare
                        if (origin["peer"] == last["peer"] and  # Same peer
                                int(origin["localpref"]) == int(last["localpref"]) and  # Same local preference
                                origin["selfOrigin"] == last["selfOrigin"] and  # Same self-origin flag
                                origin["ASPath"] == last["ASPath"] and  # Same AS path
                                origin["origin"] == last["origin"]):  # Same origin type
                            origin_prefix = self.netmask_to_prefix(origin["netmask"])  # Prefix length of origin route
                            last_prefix = self.netmask_to_prefix(last["netmask"])  # Prefix length of last route

                            if origin_prefix == last_prefix:  # Check if prefix lengths match
                                origin_ip_int = self.ip_to_int(origin["network"])  # Convert origin IP to integer
                                last_ip_int = self.ip_to_int(last["network"])  # Convert last IP to integer

                                aggregated_prefix = origin_prefix - 1  # Attempt to create a new aggregated prefix
                                if aggregated_prefix >= 0:  # If aggregation is possible
                                    if origin_ip_int < last_ip_int:  # Check if the origin IP is less than the last IP
                                        if last_ip_int == origin_ip_int + (
                                                1 << (32 - origin_prefix)):  # Check if consecutive
                                            if origin_ip_int % (1 << (
                                                    32 - aggregated_prefix)) == 0:  # Check if they fit into a new prefix
                                                new_network = self.int_to_ip(
                                                    origin_ip_int)  # Convert new network IP to string

                                                new_netmask_int = (0xFFFFFFFF << (
                                                            32 - aggregated_prefix)) & 0xFFFFFFFF  # Create new netmask
                                                new_netmask = self.int_to_ip(
                                                    new_netmask_int)  # Convert new netmask to string

                                                # New route creation
                                                new_route = {
                                                    "network": new_network,
                                                    "netmask": new_netmask,
                                                    "peer": origin["peer"],
                                                    "localpref": origin["localpref"],
                                                    "ASPath": origin["ASPath"],
                                                    "selfOrigin": origin["selfOrigin"],
                                                    "origin": origin["origin"]
                                                }

                                                # Add new route in the aggregated list!
                                                new_aggregated_list.append(new_route)

                                                # Mark as used so I can skip it!
                                                has_been_aggregated[i] = True
                                                has_been_aggregated[j] = True
                                                merged = True  # Flag that aggregation happened
                                                has_changed = True  # Set flag to true since aggregation occurred

                                                break  # Exit inner loop after successful aggregation
                    j = j + 1  # Move to next route to compare

                # If the original route was not merged, add it to the list
                if not merged and not has_been_aggregated[i]:
                    new_aggregated_list.append(origin)
                    has_been_aggregated[i] = True  # Mark as processed

                i = i + 1  # Move to next route to check

            aggregated_routes = new_aggregated_list  # Update the list of aggregated routes

        return aggregated_routes

        # updating the fowarding table
    def update_forwarding_table(self, message, source):
        message = message.get("msg", {})

        # get all the information to update the route
        network = message.get("network")
        netmask = message.get("netmask")
        local_pref = int(message.get("localpref", 0))

        self_origin = message.get("selfOrigin", False)

        if isinstance(self_origin, str):

            self_origin = (self_origin.lower() == "true")


        aspath_in = message.get("ASPath", [])

        origin = message.get("origin", "UNK")

        aspath_out = aspath_in


        new_route = {
            "network": network,
            "netmask": netmask,
            "localpref": local_pref,
            "selfOrigin": self_origin,
            "ASPath": aspath_out,
            "origin": origin,
            "peer": source
        }

        new_routes = []
        for route in self.forwarding_table:
            if not (route["network"] == network and route["netmask"] == netmask and route["peer"] == source):
                new_routes.append(route)

        new_routes.append(new_route)
        self.forwarding_table = new_routes

        self.send_updates(new_route, source)

    def ip_to_int(self, ip):
        # Split the IP address into its four octets (parts)
        split_ip = ip.split('.')

        # Convert each part of the IP address to an integer
        part1 = int(split_ip[0])
        part2 = int(split_ip[1])
        part3 = int(split_ip[2])
        part4 = int(split_ip[3])

        # Shift each part to its corresponding position in a 32-bit integer
        shifted_part1 = part1 << 24  # Shift the first octet 24 bits to the left
        shifted_part2 = part2 << 16  # Shift the second octet 16 bits to the left
        shifted_part3 = part3 << 8  # Shift the third octet 8 bits to the left
        shifted_part4 = part4  # No shift for the last octet

        # Combine the shifted parts into a single 32-bit integer using bitwise OR
        result = shifted_part1 | shifted_part2 | shifted_part3 | shifted_part4

        # Return the resulting 32-bit integer
        return result

    def int_to_ip(self, n):
        # Extract each octet from the 32-bit integer by shifting and masking
        octet1 = (n >> 24) & 0xFF  # Extract the first octet by shifting right 24 bits
        octet2 = (n >> 16) & 0xFF  # Extract the second octet by shifting right 16 bits
        octet3 = (n >> 8) & 0xFF  # Extract the third octet by shifting right 8 bits
        octet4 = n & 0xFF  # Extract the last octet by masking with 0xFF

        # Convert the octets into a string representation of the IP address
        return f"{octet1}.{octet2}.{octet3}.{octet4}"




    ## helper to make a copy for the message
    def make_copy(self, message):
        copy_message = {
                "src": message["src"],
                "dst": message["dst"],
                "next_hop": message["msg"].get("network"),
                "relation": self.relations.get(message["src"]),
                "msg":
                    {
                    "origin": message["msg"].get("origin"),
                    "localpref": message["msg"].get("localpref"),
                    "network": message["msg"].get("network"),
                    "ASPath": message["msg"].get("ASPath", []),
                    "netmask": message["msg"].get("netmask"),
                    "selfOrigin": message["msg"].get("selfOrigin"),
                    }

        }

        return copy_message

    def send_updates(self, route, sender):
        sender_relation = self.relations.get(sender)  # Get sender's relationship type

        # Loop through neighbors to determine who to send the update to
        for neighbor, neighbor_relation in self.relations.items():
            fwd_msg = {
                "src": str(self.our_addr(neighbor)),
                "dst": neighbor,
                "type": "update",
                "msg": {
                    "network": route["network"],
                    "netmask": route["netmask"],
                    "ASPath": [self.asn] + route["ASPath"]
                }
            }

            # Skip the sender to avoid sending the update back to the same node
            if neighbor == sender:
                continue

            # Define the update message content (based on the current route)

            # Handle sending based on the sender's relation and the neighbor's relation
            if sender_relation == "cust":
                # If sender is a customer, send update to everyone
                self.send(neighbor, json.dumps(fwd_msg))
            elif sender_relation in ["peer", "prov"] and neighbor_relation == "cust":
                # If the sender is a peer or provider, send the update to customer neighbors only
                self.send(neighbor, json.dumps(fwd_msg))

        def send_withdraw(self, remove_list, sender):
            sender_relation = self.relations.get(sender)
            for neighbor, neighbor_relation in self.relations.items():
                fwd_msg = {
                    "msg": remove_list,
                    "src": str(self.our_addr(neighbor)),
                    "dst": neighbor,
                    "type": "withdraw",
                }

                if neighbor == sender:
                    continue
                if sender_relation is "cust":
                    self.send(neighbor, json.dumps(fwd_msg))
                elif sender_relation in ["peer", "prov"] and neighbor_relation == "cust":
                    self.send(neighbor, json.dumps(fwd_msg))


    def drop_data(self, data):
        update_message = {
            "src": data["src"],
            "dst": data["dst"],
            "type": "no route",
            "msg": {}
        }
        self.send(data["src"], json.dumps(update_message))


## taking care of constructing the best and creating the first hop
    def handle_data_message(self, data, source):
        dst = data.get("dst")
        best_route = self.find_the_best_route(dst)
        if best_route is None:
            no_route = {
                "src": str(self.our_addr(source)),
                "dst": data.get("src"),
                "type": "no route",
                "msg": {}
            }
            self.send(source, json.dumps(no_route))
        self.send_data_routers(best_route, data,  source)


        return

    def find_the_best_route(self, dst):
        best_route = None
        longest_prefix = -1  # Track the most specific match
        for route in self.forwarding_table:
                network = route.get("network")
                netmask = route.get("netmask")
                local_pref = route.get("localpref")
                self_origin = route.get("selfOrigin", )
                as_path = route.get("ASPath")
                origin = route.get("origin")

                if self.ip_in_network(dst, network, netmask):  # checks if the data's dst is within the network

                    netmask_length = self.netmask_to_prefix(netmask)
                    # Check for longest prefix match

                    if netmask_length > longest_prefix:  # picks the one with the hight prefix
                        longest_prefix = netmask_length
                        best_route = route

                    elif netmask_length == longest_prefix:
                        # Compare based on Local Preference
                        if local_pref > best_route.get("localpref"):
                            best_route = route

                        elif local_pref == best_route.get("localpref"):

                            # Prefer self-originated routes
                            if self_origin and not best_route.get("selfOrigin"):
                                best_route = route


                            elif len(as_path) < len(best_route.get("ASPath")):
                                best_route = route


                            elif len(as_path) == len(best_route.get("ASPath")):
                                # Compare origin type
                                best_origin = best_route.get("origin")

                                if origin == "IGP" and best_origin != "IGP":
                                    best_route = route


                                elif origin == "EGP" and best_origin == "UNK":
                                    best_route = route


                                elif origin == best_origin:
                                    # Break tie using lower source IP
                                    if route["peer"] < best_route["peer"]:
                                        best_route = route



        return best_route



    def ip_to_binary(self, ip):
        ip_bi =  "".join(bin(int(octet))[2:].zfill(8) for octet in ip.split("."))

        return ip_bi

    def netmask_to_prefix(self, netmask):
        netmask_number = sum(bin(int(octet)).count('1') for octet in netmask.split('.'))

        return  netmask_number

    def ip_in_network(self, ip, network, netmask):
        # Convert netmask to prefix length
        prefix_length = self.netmask_to_prefix(netmask)

        # Convert to binary
        network_bin = self.ip_to_binary(network)
        ip_bin = self.ip_to_binary(ip)

        # Extract relevant portion
        ip_prefix = ip_bin[:prefix_length]
        network_prefix = network_bin[:prefix_length]
        return ip_prefix == network_prefix


def send_data_routers(self, best_route, data, source):
    # Retrieve the relationship type of the source router (e.g., 'peer', 'cust', etc.)
    sender_relation = self.relations.get(source)

    # Retrieve the relationship type of the best route's peer router
    des_relation = self.relations.get(best_route["peer"])

    # If the sender's relation is None (not found), exit the function
    if sender_relation is None:
        return

    # Check if both sender and destination routers have a "peer" relationship
    if sender_relation == "peer" and des_relation == "peer":
        # If both are peers, send a "no route" message back to the source
        no_route = {
            "src": str(self.our_addr(source)),  # Get the source address of the sender
            "dst": data.get("src"),  # The destination is the source of the data message
            "type": "no route",  # Type of the message is "no route"
            "msg": {}  # Empty message body
        }

        # Send the "no route" message to the source to indicate there's no valid route
        self.send(source, json.dumps(no_route))

    # Forward the data message to the best route's peer
    self.send(best_route["peer"], json.dumps(data))


def handle_withdrawel(self, message, source):
    # Get the list of routes to be removed from the message
    remove_list = message.get("msg", [])
    has_been_removed = False  # Flag to track if anything has been removed

    # Loop through each item in the removal list
    for removing_item in remove_list:
        network = removing_item.get("network")  # Get the network of the route to be removed
        netmask = removing_item.get("netmask")  # Get the netmask of the route to be removed

        # Store the length of the forwarding table before removal
        before_list = len(self.forwarding_table)

        # Build a new list for forwarding table with routes that are not removed
        new_list = []

        # Loop through all routes in the forwarding table
        for route in self.forwarding_table:
            # Skip routes that match the network, netmask, and source peer
            if (route["network"] == network and
                    route["netmask"] == netmask and
                    route["peer"] == source):
                continue  # This route should be removed

            # Add remaining routes to the new list
            new_list.append(route)

        # Update the forwarding table with the new list after removal
        self.forwarding_table = new_list

        # If the size of the forwarding table has decreased, a route was removed
        if len(self.forwarding_table) < before_list:
            has_been_removed = True

    # If any routes were removed, send a withdrawal message to notify others
    if has_been_removed:
        self.send_withdraw(remove_list, source)


def send_withdraw(self, remove_list, sender):
    # Get the relation type of the sender (customer, provider, or peer)
    sender_relation = self.relations.get(sender)

    # Loop through all neighbors in the relations
    for neighbor, neighbor_relation in self.relations.items():
        # Build the withdrawal message with the list of routes to be removed
        fwd_msg = {
            "msg": remove_list,
            "src": str(self.our_addr(neighbor)),  # Get the source address for the neighbor
            "dst": neighbor,  # Set the destination as the neighbor
            "type": "withdraw",  # Type of message is "withdraw"
        }

        # Skip sending the message to the sender
        if neighbor == sender:
            continue

        # If the sender is a customer, send the withdrawal message to the neighbor
        if sender_relation == "cust":
            self.send(neighbor, json.dumps(fwd_msg))

        # If the sender is a peer or provider and the neighbor is a customer, send the message
        elif sender_relation in ["peer", "prov"] and neighbor_relation == "cust":
            self.send(neighbor, json.dumps(fwd_msg))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")


    args = parser.parse_args()
    router = Router(args.asn, args.connections)

    router.run()